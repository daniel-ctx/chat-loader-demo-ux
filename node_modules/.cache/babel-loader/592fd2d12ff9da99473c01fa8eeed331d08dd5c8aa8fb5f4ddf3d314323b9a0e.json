{"ast":null,"code":"var _jsxFileName = \"/Users/daniel/Desktop/chat-response/src/components/AnimatedPlaceholder/AnimatedPlaceholder.js\",\n  _s = $RefreshSig$();\n// AnimatedPlaceholder.js\nimport React, { useEffect, useState } from 'react';\nimport './AnimatedPlaceholder.scss';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function AnimatedPlaceholder({\n  messages,\n  inputFocused,\n  inputHtml\n}) {\n  _s();\n  const [placeholderIdx, setPlaceholderIdx] = useState(0);\n  const [placeholderText, setPlaceholderText] = useState('');\n  const [typing, setTyping] = useState(true); // true: digitando, false: apagando\n\n  useEffect(() => {\n    let timeout;\n    const fullText = messages[placeholderIdx];\n    if (typing) {\n      if (placeholderText.length < fullText.length) {\n        timeout = setTimeout(() => {\n          setPlaceholderText(fullText.slice(0, placeholderText.length + 1));\n        }, 30);\n      } else {\n        // Espera antes de começar a apagar\n        timeout = setTimeout(() => setTyping(false), 8000);\n      }\n    } else {\n      if (placeholderText.length > 0) {\n        timeout = setTimeout(() => {\n          setPlaceholderText(fullText.slice(0, placeholderText.length - 1));\n        }, 15);\n      } else {\n        // Troca para a próxima frase e começa a digitar\n        timeout = setTimeout(() => {\n          setPlaceholderIdx(idx => (idx + 1) % messages.length);\n          setTyping(true);\n        }, 300);\n      }\n    }\n    return () => clearTimeout(timeout);\n  }, [placeholderText, typing, placeholderIdx, messages]);\n\n  // Quando muda a frase, zera o texto\n  useEffect(() => {\n    setPlaceholderText('');\n  }, [placeholderIdx]);\n  if (inputHtml && inputHtml !== '<br>' || inputFocused) return null;\n  return /*#__PURE__*/_jsxDEV(\"span\", {\n    className: \"chat-input-placeholder\",\n    children: placeholderText\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 46,\n    columnNumber: 5\n  }, this);\n}\n_s(AnimatedPlaceholder, \"fsj251vOzY1SKf1UOZg2ff5t1Z8=\");\n_c = AnimatedPlaceholder;\nvar _c;\n$RefreshReg$(_c, \"AnimatedPlaceholder\");","map":{"version":3,"names":["React","useEffect","useState","jsxDEV","_jsxDEV","AnimatedPlaceholder","messages","inputFocused","inputHtml","_s","placeholderIdx","setPlaceholderIdx","placeholderText","setPlaceholderText","typing","setTyping","timeout","fullText","length","setTimeout","slice","idx","clearTimeout","className","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/daniel/Desktop/chat-response/src/components/AnimatedPlaceholder/AnimatedPlaceholder.js"],"sourcesContent":["// AnimatedPlaceholder.js\nimport React, { useEffect, useState } from 'react';\nimport './AnimatedPlaceholder.scss';\n\nexport default function AnimatedPlaceholder({ messages, inputFocused, inputHtml }) {\n  const [placeholderIdx, setPlaceholderIdx] = useState(0);\n  const [placeholderText, setPlaceholderText] = useState('');\n  const [typing, setTyping] = useState(true); // true: digitando, false: apagando\n\n  useEffect(() => {\n    let timeout;\n    const fullText = messages[placeholderIdx];\n    if (typing) {\n      if (placeholderText.length < fullText.length) {\n        timeout = setTimeout(() => {\n          setPlaceholderText(fullText.slice(0, placeholderText.length + 1));\n        }, 30);\n      } else {\n        // Espera antes de começar a apagar\n        timeout = setTimeout(() => setTyping(false), 8000);\n      }\n    } else {\n      if (placeholderText.length > 0) {\n        timeout = setTimeout(() => {\n          setPlaceholderText(fullText.slice(0, placeholderText.length - 1));\n        }, 15);\n      } else {\n        // Troca para a próxima frase e começa a digitar\n        timeout = setTimeout(() => {\n          setPlaceholderIdx(idx => (idx + 1) % messages.length);\n          setTyping(true);\n        }, 300);\n      }\n    }\n    return () => clearTimeout(timeout);\n  }, [placeholderText, typing, placeholderIdx, messages]);\n\n  // Quando muda a frase, zera o texto\n  useEffect(() => {\n    setPlaceholderText('');\n  }, [placeholderIdx]);\n\n  if ((inputHtml && inputHtml !== '<br>') || inputFocused) return null;\n\n  return (\n    <span className=\"chat-input-placeholder\">{placeholderText}</span>\n  );\n} "],"mappings":";;AAAA;AACA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAClD,OAAO,4BAA4B;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEpC,eAAe,SAASC,mBAAmBA,CAAC;EAAEC,QAAQ;EAAEC,YAAY;EAAEC;AAAU,CAAC,EAAE;EAAAC,EAAA;EACjF,MAAM,CAACC,cAAc,EAAEC,iBAAiB,CAAC,GAAGT,QAAQ,CAAC,CAAC,CAAC;EACvD,MAAM,CAACU,eAAe,EAAEC,kBAAkB,CAAC,GAAGX,QAAQ,CAAC,EAAE,CAAC;EAC1D,MAAM,CAACY,MAAM,EAAEC,SAAS,CAAC,GAAGb,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;;EAE5CD,SAAS,CAAC,MAAM;IACd,IAAIe,OAAO;IACX,MAAMC,QAAQ,GAAGX,QAAQ,CAACI,cAAc,CAAC;IACzC,IAAII,MAAM,EAAE;MACV,IAAIF,eAAe,CAACM,MAAM,GAAGD,QAAQ,CAACC,MAAM,EAAE;QAC5CF,OAAO,GAAGG,UAAU,CAAC,MAAM;UACzBN,kBAAkB,CAACI,QAAQ,CAACG,KAAK,CAAC,CAAC,EAAER,eAAe,CAACM,MAAM,GAAG,CAAC,CAAC,CAAC;QACnE,CAAC,EAAE,EAAE,CAAC;MACR,CAAC,MAAM;QACL;QACAF,OAAO,GAAGG,UAAU,CAAC,MAAMJ,SAAS,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC;MACpD;IACF,CAAC,MAAM;MACL,IAAIH,eAAe,CAACM,MAAM,GAAG,CAAC,EAAE;QAC9BF,OAAO,GAAGG,UAAU,CAAC,MAAM;UACzBN,kBAAkB,CAACI,QAAQ,CAACG,KAAK,CAAC,CAAC,EAAER,eAAe,CAACM,MAAM,GAAG,CAAC,CAAC,CAAC;QACnE,CAAC,EAAE,EAAE,CAAC;MACR,CAAC,MAAM;QACL;QACAF,OAAO,GAAGG,UAAU,CAAC,MAAM;UACzBR,iBAAiB,CAACU,GAAG,IAAI,CAACA,GAAG,GAAG,CAAC,IAAIf,QAAQ,CAACY,MAAM,CAAC;UACrDH,SAAS,CAAC,IAAI,CAAC;QACjB,CAAC,EAAE,GAAG,CAAC;MACT;IACF;IACA,OAAO,MAAMO,YAAY,CAACN,OAAO,CAAC;EACpC,CAAC,EAAE,CAACJ,eAAe,EAAEE,MAAM,EAAEJ,cAAc,EAAEJ,QAAQ,CAAC,CAAC;;EAEvD;EACAL,SAAS,CAAC,MAAM;IACdY,kBAAkB,CAAC,EAAE,CAAC;EACxB,CAAC,EAAE,CAACH,cAAc,CAAC,CAAC;EAEpB,IAAKF,SAAS,IAAIA,SAAS,KAAK,MAAM,IAAKD,YAAY,EAAE,OAAO,IAAI;EAEpE,oBACEH,OAAA;IAAMmB,SAAS,EAAC,wBAAwB;IAAAC,QAAA,EAAEZ;EAAe;IAAAa,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAO,CAAC;AAErE;AAACnB,EAAA,CA3CuBJ,mBAAmB;AAAAwB,EAAA,GAAnBxB,mBAAmB;AAAA,IAAAwB,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}